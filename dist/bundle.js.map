{"version":3,"sources":["webpack://unischeduler_web_ts/./src/unischeduler.ts","webpack://unischeduler_web_ts/webpack/startup"],"names":["reClassName","reClassSection","reLeadingLineWhitespace","reEndingLineWhitespace","reNewlines","reClassTime","SchedulerError","Error","m","super","Object","setPrototypeOf","this","prototype","createClassSection","className","type","weekdays","startTime","endTime","location","professors","startDate","endDate","byDay","match","toString","dtstart","makeDateTime","date","byday","toLowerCase","includes","toUTCString","slice","setUTCDate","getUTCDate","setTrueWeekday","dtend","until","setUTCHours","summary","start","end","description","replace","rrule","freq","time","timeInfo","exec","groups","datetime","Date","hours","parseInt","noonIncrement","isAfterNoon","setUTCMinutes","minutes","add_exdates","icalEvent","exdates","getUTCHours","getUTCMinutes","exdatesCopies","exdate","newDate","getTime","push","exclude","normalizeWhitespace","str","getAllRegexMatches","regex","matches","window","convertToIcal","schedule","isUCF","timezone","trim","class_sections","classNames","classSectionBatches","split","shift","all_class_sections","i","length","rawSectionBatch","sectionType","sectionBatch","lastSectionType","section","info","parseSchedule","no_school_events","firstSectionStartDate","year","getUTCFullYear","term","sectionDate","start_month","getUTCMonth","getSectionTerm","url","response","html","fetch","DOMParser","parseFromString","text","exception","raw_events","querySelectorAll","scrapped_events","raw_event","elem","title","querySelector","textContent","raw_description","scrap_no_school_events","dates","noSchoolEvent","day_count","console","log","map","d","make_timeless_exdates","name","classSections","noSchoolEvents","ical","ics","ICS","tz","e","toDatetime","toExdateList","toDate","normalize","createIcalString","dt","toTime","pad","getUTCSeconds","join","foldLine","n","line","parts"],"mappings":"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","file":"bundle.js","sourcesContent":["// Good luck figuring this out!\nconst reClassName = /[A-Z]{3}[A-Z]* \\d+[A-Z]? - .+/g;\nconst reClassSection = /(?:(?<sectionType>[A-Z][a-z]+)\\n)?(?<weekdays>(?:[A-Z][a-z])+)\\s+(?<startTime>\\d\\d?:\\d\\d(?:AM|PM))\\s+-\\s+(?<endTime>\\d\\d?:\\d\\d(?:AM|PM))\\n(?<location>.+)\\n(?<professors>\\D+)(?<dtstart>[\\d/]+)\\s+-\\s+(?<dtend>[\\d/]+)/g;\n\n// Yes, they MUST be separate and CANNOT be combined\n// Otherwise, js can sometimes remove necessary newlines\nconst reLeadingLineWhitespace = /(^\\s+)/gm\nconst reEndingLineWhitespace = /(\\s+$)/gm\n\nconst reNewlines = /\\n+/gm\n\nconst reClassTime = /(?<hours>\\d+)(?::)(?<minutes>\\d+)(?<isAfterNoon>PM)?/;\n\nconst TZ_NEW_YORK = \"America/New_York\"\n\nconst NUMBER_OF_MILLIS_IN_DAY = 86400000\n\nclass SchedulerError extends Error {\n    constructor(m: string) {\n        super(m);\n\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, SchedulerError.prototype);\n    }\n}\n\ninterface RRule {\n    freq: string;\n    byDay: string;\n    until: Date;\n    exclude?: Date[];\n}\n\ninterface IcalEvent {\n    summary: string;\n    start: Date;\n    end: Date;\n    description: string;\n}\n\ninterface ClassSectionEvent extends IcalEvent {\n    location: string;\n    rrule: RRule\n}\n\nfunction createClassSection(\n    className: string, type: string, weekdays: string,\n    startTime: string, endTime: string, location: string,\n    professors: string, startDate: string, endDate: string): ClassSectionEvent {\n    let byDay = weekdays.match(/../g).toString();\n    let dtstart = makeDateTime(startDate, startTime);\n    setTrueWeekday(dtstart, byDay);\n    let dtend = makeDateTime(startDate, endTime);\n    dtend.setUTCDate(dtstart.getUTCDate());\n    let until = makeDateTime(endDate, endTime);\n    until.setUTCHours(0, 0, 0, 0);\n    return {\n        summary: `${className} (${type})`,\n        start: dtstart,\n        end: dtend,\n        location: location,\n        description: \"Professors: \" + professors.replace(/\\n/gm, ' '),\n        rrule: {\n            freq: \"WEEKLY\",\n            byDay: byDay,\n            until: until,\n        }\n    }\n}\n\nfunction makeDateTime(date: string, time: string) {\n    let timeInfo = reClassTime.exec(time).groups;\n    if (!timeInfo)\n        throw new SchedulerError(\"TIMEINFO ERROR\");\n    let datetime = new Date(date);\n    let hours = parseInt(timeInfo.hours)\n    let noonIncrement: number = 0;\n    if (timeInfo.isAfterNoon && hours < 12)\n        noonIncrement = 12;\n    else if (!timeInfo.isAfterNoon && hours == 12)\n        noonIncrement = -12;\n    datetime.setUTCHours(hours + noonIncrement);\n    datetime.setUTCMinutes(parseInt(timeInfo.minutes));\n    return datetime;\n}\n\nfunction setTrueWeekday(date: Date, byday: string) {\n    byday = byday.toLowerCase()\n    while (!byday.includes(date.toUTCString().slice(0, 2).toLowerCase()))\n        date.setUTCDate(date.getUTCDate() + 1)\n}\n\n\n// MAIN\n// @ts-ignore\nwindow.convertToIcal = async function (schedule: string, isUCF: boolean, timezone: string) {\n    schedule = schedule.trim();\n    if (!schedule)\n        throw new SchedulerError(\"You inputted an empty schedule.\");\n    let class_sections = parseSchedule(schedule);\n    if (!class_sections)\n        throw new SchedulerError(\"Couldn't find any class sections in your schedule. Please, check your schedule or contact my author.\");\n    let firstSectionStartDate = class_sections[0].start;\n    let year = firstSectionStartDate.getUTCFullYear();\n    let term = getSectionTerm(firstSectionStartDate);\n    let no_school_events: IcalEvent[];\n    if (isUCF)\n        no_school_events = await scrap_no_school_events(year, term);\n    else\n        no_school_events = [];\n    let exdates = make_timeless_exdates(no_school_events);\n    for (let section of class_sections)\n        add_exdates(section, exdates);\n    return createIcalString(`Classes ${term} ${year}`, timezone, class_sections, no_school_events)\n}\n\nfunction getSectionTerm(sectionDate: Date): string {\n    let start_month = sectionDate.getUTCMonth();\n    if (7 <= start_month && start_month <= 9)\n        return \"Fall\";\n    else if (0 <= start_month && start_month <= 2)\n        return \"Spring\";\n    else\n        return \"Summer\";\n}\n\n\nfunction make_timeless_exdates(no_school_events: IcalEvent[]): Date[] {\n    let dates = [];\n    for (let noSchoolEvent of no_school_events) {\n        let day_count = (noSchoolEvent.end.getTime() - noSchoolEvent.start.getTime()) / NUMBER_OF_MILLIS_IN_DAY;\n        if (day_count > 1)\n            for (let i = 0; i < day_count + 1; i++) {\n                let newDate = new Date(noSchoolEvent.start);\n                newDate.setUTCDate(newDate.getUTCDate() + i); // This might need to be converted to UTC\n                dates.push(newDate);\n            }\n        else\n            dates.push(noSchoolEvent.start);\n    }\n    console.log(dates.map((d) => {\n        return d.toUTCString()\n    }))\n    return dates;\n}\n\n// If DTSTART is a date-time value then EXDATEs must also be date-times (c) RFC5545\nfunction add_exdates(icalEvent: ClassSectionEvent, exdates: Date[]) {\n    let hours = icalEvent.start.getUTCHours();\n    let minutes = icalEvent.start.getUTCMinutes();\n    let exdatesCopies = [];\n    for (let exdate of exdates) {\n        if (!icalEvent.rrule.byDay.toLowerCase().includes(exdate.toUTCString().slice(0, 2).toLowerCase()))\n            continue;\n        let newDate = new Date(exdate.getTime());\n        newDate.setUTCHours(hours);\n        newDate.setUTCMinutes(minutes);\n        exdatesCopies.push(newDate);\n    }\n    icalEvent.rrule.exclude = exdatesCopies;\n}\n// PARSING\n\nfunction parseSchedule(schedule: string): ClassSectionEvent[] {\n    schedule = normalizeWhitespace(schedule);\n    const classNames = schedule.match(reClassName)\n    if (!classNames)\n        throw new SchedulerError(\"Couldn't find any class sections in your schedule. Please, check your schedule or contact my author.\")\n    const classSectionBatches = schedule.split(reClassName);\n    classSectionBatches.shift() // classSectionBatches[0] == ''\n    let all_class_sections = [];\n    for (let i = 0; i < classNames.length; i++) {\n        let rawSectionBatch = classSectionBatches[i];\n        // TODO: What if we get an online class without datetimes? Is the regex enough to handle such cases?\n        // TODO: What if the class info somehow contains dropped/withdrawn but in some other section? Ex: Prof name\n        if (rawSectionBatch.includes(\"Dropped\") || rawSectionBatch.includes(\"Withdrawn\"))\n            continue;\n        let sectionBatch = getAllRegexMatches(rawSectionBatch, reClassSection)\n        let sectionType: string;\n        let lastSectionType: string = \"\";\n        for (let section of sectionBatch) {\n            let info: any = section.groups;\n            if (sectionType = info.sectionType)\n                lastSectionType = sectionType;\n            all_class_sections.push(createClassSection(\n                classNames[i], lastSectionType, info.weekdays,\n                info.startTime, info.endTime, info.location,\n                info.professors, info.dtstart, info.dtend\n            ))\n        }\n    }\n    return all_class_sections\n}\n\nfunction normalizeWhitespace(str: string): string {\n    return str.replace(reLeadingLineWhitespace, '').replace(reEndingLineWhitespace, '').replace(reNewlines, \"\\n\");\n}\n\nfunction getAllRegexMatches(str: string, regex: RegExp): RegExpExecArray[] {\n    let matches: RegExpExecArray[] = [];\n    let match: RegExpExecArray | null;\n    while ((match = regex.exec(str)) !== null)\n        matches.push(match);\n    return matches;\n}\n\n// SCRAPPER\n\nasync function scrap_no_school_events(year: number, term: string): Promise<IcalEvent[]> {\n    const url = `https://calendar.ucf.edu/${year}/${term}/no-classes/`;\n    // typeof is necessary because of this: https://github.com/microsoft/TypeScript/issues/27311\n    let response: Response, html: HTMLDocument;\n    try {\n        response = await fetch(url);\n        let parser = new DOMParser();\n        html = parser.parseFromString(await response.text(), 'text/html');\n    }\n    catch (exception) {\n        throw new SchedulerError(\"Couldn't connect to calendar.ucf.edu to get no-school events. Either check your internet connection and try again or uncheck 'I am a UCF student' tickbox.\");\n    }\n    let raw_events = html.querySelectorAll('tr.vevent')\n    let scrapped_events = [];\n    let start: Date, end: Date, dtstart: string, dtend: string, description: string, summary: string;\n    for (let raw_event of raw_events) {\n        start = end = dtstart = dtend = description = summary = null;\n        for (let elem of raw_event.querySelectorAll(\"abbr\")) {\n            if (elem.className.includes(\"dtstart\"))\n                dtstart = elem.title;\n            else if (elem.className.includes(\"dtend\"))\n                dtend = elem.title;\n        }\n        summary = raw_event.querySelector(\"span.summary\").textContent\n        // Sometimes it has an event with no dtstart and no dtend called \"Study day\"\n        if (!dtstart || !summary)\n            continue;\n        start = new Date(dtstart);\n        let raw_description = raw_event.querySelector(\"div.more-details\");\n        if (raw_description)\n            description = raw_description.textContent.trim();\n        if (!dtend) {\n            end = new Date(start.getTime())\n            end.setUTCDate(end.getUTCDate() + 1);\n        }\n        else\n            end = new Date(dtend)\n        scrapped_events.push({\n            summary: summary,\n            start: start,\n            end: end,\n            description: description ? description : \"\",\n        });\n    }\n    return scrapped_events;\n}\n\n// Да пошли вы в жопу со своими JS-библиотеками. КТО-НИБУДЬ ВООБЩЕ МОЖЕТ РЕАЛИЗОВАТЬ ПОЛНЫЙ ФУНКЦИОНАЛ ICAL?\n// Миллион библиотек, но ни одной рабочей. Сам реализую.\n\nfunction createIcalString(name: string, timezone: string, classSections: ClassSectionEvent[], noSchoolEvents: IcalEvent[]): string {\n    let ical = `BEGIN:VCALENDAR\\nSUMMARY:${name}\\nTIMEZONE:${timezone}\\n`\n    let ics = new ICS(timezone);\n    let tz = `;TZID=${timezone}`\n    for (let e of classSections)\n        ical += `\n        BEGIN:VEVENT\n        SUMMARY:${e.summary}\n        DESCRIPTION:${e.description}\n        LOCATION:${e.location}\n        DTSTART;VALUE=DATE-TIME${tz}:${ics.toDatetime(e.start)}\n        DTEND;VALUE=DATE-TIME${tz}:${ics.toDatetime(e.end)}\n        RRULE:FREQ=WEEKLY;BYDAY=${e.rrule.byDay};INTERVAL=1;UNTIL=${ics.toDatetime(e.rrule.until)}Z\n        EXDATE:${ics.toExdateList(e.rrule.exclude)}\n        END:VEVENT\n        `\n    for (let e of noSchoolEvents)\n        ical += `\n        BEGIN:VEVENT\n        SUMMARY:${e.summary}\n        DESCRIPTION:${e.description}\n        DTSTART;VALUE=DATE${tz}:${ics.toDate(e.start)}\n        DTEND;VALUE=DATE${tz}:${ics.toDate(e.end)}\n        END:VEVENT\n        `\n    ical += \"\\nEND:VCALENDAR\"\n    return ics.normalize(ical);\n}\n\n// All dates passed here must be in local timezone\n// All moments passed here must be in UTC\nclass ICS {\n    timezone: string\n\n    constructor(timezone: string) {\n        this.timezone = timezone;\n    }\n\n    toDatetime(dt: Date): string {\n        // 20210411T090000\n        return `${this.toDate(dt)}T${this.toTime(dt)}`;\n    }\n\n    toDate(dt: Date): string {\n        return dt.getUTCFullYear() + pad(dt.getUTCMonth() + 1) + pad(dt.getUTCDate());\n    }\n\n    toTime(dt: Date): string {\n        return pad(dt.getUTCHours()) + pad(dt.getUTCMinutes()) + pad(dt.getUTCSeconds());\n    }\n\n    toExdateList(dates: Date[]): string {\n        // EXDATE:20210118T090000Z,20210411T090000Z,20210412T090000Z\n        return dates.map(this.toDatetime, this).join(\",\")\n    }\n\n    // This is necessary because RFC 5545 does not allow:\n    //  trailing whitespace, blank lines, or lines longer than 75 chars\n    normalize(ical: string): string {\n        return foldLines(normalizeWhitespace(ical))\n    }\n\n}\n\n\nfunction pad(n: number): string {\n    if (n < 10)\n        return '0' + n;\n    else\n        return '' + n\n}\n\nfunction foldLines(text: string) {\n    return text.match(/[^\\r\\n]+/g)?.map(foldLine).join(\"\\r\\n\");\n}\n\nfunction foldLine(line: string) {\n    const parts = []\n    let length = 75\n    while (line.length > length) {\n        parts.push(line.slice(0, length))\n        line = line.slice(length)\n        length = 74\n    }\n    parts.push(line)\n    return parts.join('\\r\\n ')\n}","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[903]();\n"],"sourceRoot":""}