{"version":3,"sources":["webpack://unischeduler_web_ts/./src/unischeduler.ts","webpack://unischeduler_web_ts/webpack/startup"],"names":["reClassName","reClassSection","reClassTime","reLeadingLineWhitespace","reEndingLineWhitespace","SchedulerError","Error","m","super","Object","setPrototypeOf","this","prototype","createClassSection","className","type","weekdays","startTime","endTime","location","professors","startDate","endDate","byDay","match","toString","dtstart","makeDateTime","date","byday","toLowerCase","includes","toUTCString","slice","setUTCDate","getUTCDate","setTrueWeekday","dtend","until","setUTCHours","summary","description","replace","exclude","rrule","freq","time","timeInfo","exec","groups","datetime","Date","hours","parseInt","noonIncrement","isAfterNoon","setUTCMinutes","minutes","add_exdates","icalEvent","exdates","getUTCHours","getUTCMinutes","exdatesCopies","exdate","newDate","getTime","push","normalizeWhitespace","str","getAllRegexMatches","regex","matches","window","convertToIcal","schedule","isUCF","timezone","trim","class_sections","classNames","classSectionBatches","split","shift","all_class_sections","i","length","rawSectionBatch","sectionType","sectionBatch","lastSectionType","section","info","parseSchedule","no_school_events","firstSectionStartDate","year","getUTCFullYear","term","sectionDate","start_month","getUTCMonth","getSectionTerm","url","response","html","fetch","DOMParser","parseFromString","text","exception","start","end","raw_events","querySelectorAll","scrapped_events","raw_event","elem","title","querySelector","textContent","raw_description","scrap_no_school_events","dates","noSchoolEvent","day_count","console","log","map","d","make_timeless_exdates","name","classSections","noSchoolEvents","ics","ICS","tz","creationDate","toDatetime","ical","e","toExdateList","toDate","normalize","createIcalString","dt","toTime","pad","getUTCSeconds","join","foldLine","n","line","parts"],"mappings":"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","file":"bundle.js","sourcesContent":["// Good luck figuring this out!\nconst reClassName = /[A-Z]{3}[A-Z]* \\d+[A-Z]? - .+/g;\nconst reClassSection = /(?:(?<sectionType>[A-Z][a-z]+)\\n)?(?<weekdays>(?:[A-Z][a-z])+)\\s+(?<startTime>\\d\\d?:\\d\\d(?:AM|PM))\\s+-\\s+(?<endTime>\\d\\d?:\\d\\d(?:AM|PM))\\n(?<location>.+)\\n(?<professors>\\D+)(?<dtstart>[\\d/]+)\\s+-\\s+(?<dtend>[\\d/]+)/g;\nconst reClassTime = /(?<hours>\\d+)(?::)(?<minutes>\\d+)(?<isAfterNoon>PM)?/;\n\n// Yes, they MUST be separate and CANNOT be combined\n// Otherwise, js can sometimes remove necessary newlines\nconst reLeadingLineWhitespace = /(^\\s+)/gm\nconst reEndingLineWhitespace = /(\\s+$)/gm\n\n\nconst NUMBER_OF_MILLIS_IN_DAY = 86400000\n\nclass SchedulerError extends Error {\n    constructor(m: string) {\n        super(m);\n\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, SchedulerError.prototype);\n    }\n}\n\ninterface RRule {\n    freq: string;\n    byDay: string;\n    until: Date;\n}\n\ninterface IcalEvent {\n    summary: string;\n    dtstart: Date;\n    dtend: Date;\n    description: string;\n}\n\ninterface ClassSectionEvent extends IcalEvent {\n    location: string;\n    exclude: Date[];\n    rrule: RRule;\n\n}\n\nfunction createClassSection(\n    className: string, type: string, weekdays: string,\n    startTime: string, endTime: string, location: string,\n    professors: string, startDate: string, endDate: string): ClassSectionEvent {\n    let byDay = weekdays.match(/../g).toString();\n    let dtstart = makeDateTime(startDate, startTime);\n    setTrueWeekday(dtstart, byDay);\n    let dtend = makeDateTime(startDate, endTime);\n    dtend.setUTCDate(dtstart.getUTCDate());\n    let until = makeDateTime(endDate, endTime);\n    until.setUTCHours(0, 0, 0, 0);\n    return {\n        summary: `${className} (${type})`,\n        dtstart: dtstart,\n        dtend: dtend,\n        location: location,\n        description: \"Professors: \" + professors.replace(/\\n/gm, ' '),\n        exclude: [],\n        rrule: {\n            freq: \"WEEKLY\",\n            byDay: byDay,\n            until: until,\n        }\n    }\n}\n\nfunction makeDateTime(date: string, time: string) {\n    let timeInfo = reClassTime.exec(time).groups;\n    if (!timeInfo)\n        throw new SchedulerError(\"TIMEINFO ERROR\");\n    let datetime = new Date(date);\n    let hours = parseInt(timeInfo.hours)\n    let noonIncrement: number = 0;\n    if (timeInfo.isAfterNoon && hours < 12)\n        noonIncrement = 12;\n    else if (!timeInfo.isAfterNoon && hours == 12)\n        noonIncrement = -12;\n    datetime.setUTCHours(hours + noonIncrement);\n    datetime.setUTCMinutes(parseInt(timeInfo.minutes));\n    return datetime;\n}\n\nfunction setTrueWeekday(date: Date, byday: string) {\n    byday = byday.toLowerCase()\n    while (!byday.includes(date.toUTCString().slice(0, 2).toLowerCase()))\n        date.setUTCDate(date.getUTCDate() + 1)\n}\n\n\n// MAIN\n\n// We assign it to window to be able to use it from html/js on the webpage.\n// The reason we need it is because bundlers such as webpack don't leak any info about bundled packages.\n// @ts-ignore\nwindow.convertToIcal = async function (schedule: string, isUCF: boolean, timezone: string) {\n    schedule = schedule.trim();\n    if (!schedule)\n        throw new SchedulerError(\"You inputted an empty schedule.\");\n    let class_sections = parseSchedule(schedule);\n    if (!class_sections)\n        throw new SchedulerError(\"Couldn't find any class sections in your schedule. Please, check your schedule or contact my author.\");\n    let firstSectionStartDate = class_sections[0].dtstart;\n    let year = firstSectionStartDate.getUTCFullYear();\n    let term = getSectionTerm(firstSectionStartDate);\n    let no_school_events: IcalEvent[];\n    if (isUCF)\n        no_school_events = await scrap_no_school_events(year, term);\n    else\n        no_school_events = [];\n    let exdates = make_timeless_exdates(no_school_events);\n    for (let section of class_sections)\n        add_exdates(section, exdates);\n    return createIcalString(`Classes ${term} ${year}`, timezone, class_sections, no_school_events)\n}\n\nfunction getSectionTerm(sectionDate: Date): string {\n    let start_month = sectionDate.getUTCMonth();\n    if (7 <= start_month && start_month <= 9)\n        return \"Fall\";\n    else if (0 <= start_month && start_month <= 2)\n        return \"Spring\";\n    else\n        return \"Summer\";\n}\n\n\nfunction make_timeless_exdates(no_school_events: IcalEvent[]): Date[] {\n    let dates = [];\n    for (let noSchoolEvent of no_school_events) {\n        let day_count = (noSchoolEvent.dtend.getTime() - noSchoolEvent.dtstart.getTime()) / NUMBER_OF_MILLIS_IN_DAY;\n        if (day_count > 1)\n            for (let i = 0; i < day_count + 1; i++) {\n                let newDate = new Date(noSchoolEvent.dtstart);\n                newDate.setUTCDate(newDate.getUTCDate() + i); // This might need to be converted to UTC\n                dates.push(newDate);\n            }\n        else\n            dates.push(noSchoolEvent.dtstart);\n    }\n    console.log(dates.map((d) => {\n        return d.toUTCString()\n    }))\n    return dates;\n}\n\n// If DTSTART is a date-time value then EXDATEs must also be date-times (c) RFC5545\nfunction add_exdates(icalEvent: ClassSectionEvent, exdates: Date[]) {\n    let hours = icalEvent.dtstart.getUTCHours();\n    let minutes = icalEvent.dtstart.getUTCMinutes();\n    let exdatesCopies = [];\n    for (let exdate of exdates) {\n        if (!icalEvent.rrule.byDay.toLowerCase().includes(exdate.toUTCString().slice(0, 2).toLowerCase()))\n            continue;\n        let newDate = new Date(exdate.getTime());\n        newDate.setUTCHours(hours);\n        newDate.setUTCMinutes(minutes);\n        exdatesCopies.push(newDate);\n    }\n    icalEvent.exclude = exdatesCopies;\n}\n// PARSING\n\nfunction parseSchedule(schedule: string): ClassSectionEvent[] {\n    schedule = normalizeWhitespace(schedule);\n    const classNames = schedule.match(reClassName)\n    if (!classNames)\n        throw new SchedulerError(\"Couldn't find any class sections in your schedule. Please, check your schedule or contact my author.\")\n    const classSectionBatches = schedule.split(reClassName);\n    classSectionBatches.shift() // classSectionBatches[0] == ''\n    let all_class_sections = [];\n    for (let i = 0; i < classNames.length; i++) {\n        let rawSectionBatch = classSectionBatches[i];\n        // TODO: What if we get an online class without datetimes? Is the regex enough to handle such cases?\n        // TODO: What if the class info somehow contains dropped/withdrawn but in some other section? Ex: Prof name\n        if (rawSectionBatch.includes(\"Dropped\") || rawSectionBatch.includes(\"Withdrawn\"))\n            continue;\n        let sectionBatch = getAllRegexMatches(rawSectionBatch, reClassSection)\n        let sectionType: string;\n        let lastSectionType: string = \"\";\n        for (let section of sectionBatch) {\n            let info: any = section.groups;\n            if (sectionType = info.sectionType)\n                lastSectionType = sectionType;\n            all_class_sections.push(createClassSection(\n                classNames[i], lastSectionType, info.weekdays,\n                info.startTime, info.endTime, info.location,\n                info.professors, info.dtstart, info.dtend\n            ))\n        }\n    }\n    return all_class_sections\n}\n\nfunction normalizeWhitespace(str: string): string {\n    return str.replace(reLeadingLineWhitespace, '').replace(reEndingLineWhitespace, '').replace(/\\n+/gm, \"\\n\");\n}\n\nfunction getAllRegexMatches(str: string, regex: RegExp): RegExpExecArray[] {\n    let matches: RegExpExecArray[] = [];\n    let match: RegExpExecArray | null;\n    while ((match = regex.exec(str)) !== null)\n        matches.push(match);\n    return matches;\n}\n\n// SCRAPPER\n\nasync function scrap_no_school_events(year: number, term: string): Promise<IcalEvent[]> {\n    const url = `https://calendar.ucf.edu/${year}/${term}/no-classes/`;\n    // typeof is necessary because of this: https://github.com/microsoft/TypeScript/issues/27311\n    let response: Response, html: HTMLDocument;\n    try {\n        response = await fetch(url);\n        let parser = new DOMParser();\n        html = parser.parseFromString(await response.text(), 'text/html');\n    }\n    catch (exception) {\n        throw new SchedulerError(\"Couldn't connect to calendar.ucf.edu to get no-school events. Either check your internet connection and try again or uncheck 'I am a UCF student' tickbox.\");\n    }\n    let raw_events = html.querySelectorAll('tr.vevent')\n    let scrapped_events = [];\n    let start: Date, end: Date, dtstart: string, dtend: string, description: string, summary: string;\n    for (let raw_event of raw_events) {\n        start = end = dtstart = dtend = description = summary = null;\n        for (let elem of raw_event.querySelectorAll(\"abbr\")) {\n            if (elem.className.includes(\"dtstart\"))\n                dtstart = elem.title;\n            else if (elem.className.includes(\"dtend\"))\n                dtend = elem.title;\n        }\n        summary = raw_event.querySelector(\"span.summary\").textContent\n        // Sometimes it has an event with no dtstart and no dtend called \"Study day\"\n        if (!dtstart || !summary)\n            continue;\n        start = new Date(dtstart);\n        let raw_description = raw_event.querySelector(\"div.more-details\");\n        if (raw_description)\n            description = raw_description.textContent.trim();\n        if (!dtend) {\n            end = new Date(start.getTime())\n            end.setUTCDate(end.getUTCDate() + 1);\n        }\n        else\n            end = new Date(dtend)\n        scrapped_events.push({\n            summary: summary,\n            dtstart: start,\n            dtend: end,\n            description: description ? description : \"\",\n        });\n    }\n    return scrapped_events;\n}\n\n// Да пошли вы в жопу со своими JS-библиотеками. КТО-НИБУДЬ ВООБЩЕ МОЖЕТ РЕАЛИЗОВАТЬ ПОЛНЫЙ ФУНКЦИОНАЛ ICAL?\n// Миллион библиотек, но ни одной рабочей. Сам реализую.\n// P.s. https://xkcd.com/927/\n\nfunction createIcalString(name: string, timezone: string, classSections: ClassSectionEvent[], noSchoolEvents: IcalEvent[]): string {\n    let ics = new ICS(timezone);\n    let tz = `;TZID=${timezone}`\n    let creationDate = ics.toDatetime(new Date()) + \"Z\"\n    let ical = `\n    BEGIN:VCALENDAR\n    SUMMARY:${name}\n    PRODID:-//Ovsyanka83//UnischedulerTS MIMEDIR//EN\n    VERSION:2.0\n    DTSTAMP:${creationDate}\n    CREATED:${creationDate}\n    LAST-MODIFIED:${creationDate}\n    `\n    for (let e of classSections)\n        ical += `\n        BEGIN:VEVENT\n        SUMMARY:${e.summary}\n        DESCRIPTION:${e.description}\n        LOCATION:${e.location}\n        DTSTART;VALUE=DATE-TIME${tz}:${ics.toDatetime(e.dtstart)}\n        DTEND;VALUE=DATE-TIME${tz}:${ics.toDatetime(e.dtend)}\n        RRULE:FREQ=WEEKLY;BYDAY=${e.rrule.byDay};INTERVAL=1;UNTIL=${ics.toDatetime(e.rrule.until)}Z\n        EXDATE:${ics.toExdateList(e.exclude)}\n        END:VEVENT\n        `\n    for (let e of noSchoolEvents)\n        ical += `\n        BEGIN:VEVENT\n        SUMMARY:${e.summary}\n        DESCRIPTION:${e.description}\n        DTSTART;VALUE=DATE${tz}:${ics.toDate(e.dtstart)}\n        DTEND;VALUE=DATE${tz}:${ics.toDate(e.dtend)}\n        END:VEVENT\n        `\n    ical += \"\\nEND:VCALENDAR\"\n    return ics.normalize(ical);\n}\n\nclass ICS {\n    timezone: string\n\n    constructor(timezone: string) {\n        this.timezone = timezone;\n    }\n\n    toDatetime(dt: Date): string {\n        // 20210411T090000\n        return `${this.toDate(dt)}T${this.toTime(dt)}`;\n    }\n\n    toDate(dt: Date): string {\n        // 20210411\n        return dt.getUTCFullYear() + pad(dt.getUTCMonth() + 1) + pad(dt.getUTCDate());\n    }\n\n    toTime(dt: Date): string {\n        // 093000\n        return pad(dt.getUTCHours()) + pad(dt.getUTCMinutes()) + pad(dt.getUTCSeconds());\n    }\n\n    toExdateList(dates: Date[]): string {\n        // EXDATE:20210118T090000Z,20210411T090000Z,20210412T090000Z\n        return dates.map(this.toDatetime, this).join(\",\")\n    }\n\n    // This is necessary because RFC 5545 does not allow:\n    //  trailing whitespace, blank lines, or lines longer than 75 chars\n    normalize(ical: string): string {\n        return foldLines(normalizeWhitespace(ical))\n    }\n\n}\n\nfunction pad(n: number): string {\n    if (n < 10)\n        return '0' + n;\n    else\n        return '' + n\n}\n\nfunction foldLines(text: string) {\n    return text.match(/[^\\r\\n]+/g)?.map(foldLine).join(\"\\r\\n\");\n}\n\nfunction foldLine(line: string) {\n    const parts = []\n    let length = 75\n    while (line.length > length) {\n        parts.push(line.slice(0, length))\n        line = line.slice(length)\n        length = 74\n    }\n    parts.push(line)\n    return parts.join('\\r\\n ')\n}","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[903]();\n"],"sourceRoot":""}